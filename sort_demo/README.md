## 排序算法

#### 数组

计算机中存储多项数据，两种基本方式就是数组和链表，二者各有优缺点。

数组存储是使用连续的存储空间来进行数据的存储，这也就意味着数组的大小必须提前规划好（扩容麻烦），还有数据的插入和删除操作会很麻烦。

元素的位置称为索引，而在计算机中，基本上所有的索引都是从0开始的，从0开始让代码的编写更加容易。

注意的是数组里面的元素必须是同一种类型。

#### 链表

上面说了数组，下面就是链表，链表与数组恰恰相反，链表的元素可以存储在任何地方，每个元素都存储了下一个元素的地址，但缺点就在此，
随机存储意味着元素的获取会很难，只能从头到尾进行遍历来进行查询，但是相对的插入和删除只需要修改前后的执行地址就ok。

#### 二者操作时间复杂度对比

二者是完全相反的操作。

|         | 数组  | 链表 |
|  ----  | ----  | ---- |
| 插入  | O(n) | O(1) |
| 删除  | O(n) | O(1) |
| 查询  | O(1) | O(n) |

#### 选择排序的实现

SelectSortDemo.java

选择排序的时间复杂度O（n^2）

### 递归

递归简单的理解的就是自己调用自己。涉及到的条件有两个：

- 基准条件：也就是不调用的自己的条件，否则会无限调用自己，调用栈就会溢出。
- 递归条件：也就是自己调用自己的条件，完成递归的关键条件。

涉及到的概念就是一个调用栈，这里有个栈结构，栈是一个先进后出的结构，递归调用就是一个调用栈完成的，递归条件是压栈的操作，
基准条件就是出栈的操作，所有的函数调用都是进入了调用栈，但是也说了，调用栈不宜太深，否则会出现栈溢出的可能。

### 分而治之

分而治之是一个解决问题的很好的思路，自己理解就是无限分解，知道自己会为止，递归其实是分而治之思想的一种体现。

RecursiveDemo.java 展示了一些递归的简单案例。

其实前面说到的二分查找其实就是利用了分而治之的思路，基准条件就是找到或者min > max，递归条件就是min < max和未找到。

#### 快速排序

快速排序的思路就是选取一个基准值，然后遍历整个集合，将集合分为两个部分，一个是比他小的，一个是比他大的，然后相同的思路
将小集合和大集合按照相同的方法进行分组排序。

重点就在于基准值的选择，如果基准值的选择不合理，那算法的时间会受到一定的影响。

QuickSort.java 中掩饰了快速排序的实现。快速排序的时间是O（n log n）。

实现快速排序很依赖基准值的选择，所以建议随机选择基准值，上面是使用了中间的元素作为基准值，因为如果是有序的集合，选择第一个元素
作为基准值，这个时候的运行时间就是 O（n^2），相对于选择排序的时间更长，当然这是最糟糕的情况，平均情况下的运行时间是上面的表示。





 